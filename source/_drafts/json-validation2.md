---
title: 一种在C++中进行JSON字段校验的方法[2]
date: 2017-04-19 19:33:53
categories: C++
tags: 
- json
- validation
---

上一篇中说明了这个JSON字段校验器要做的事情，这一篇会分析一下如果想要实现一个易于扩展的验证器，需要考虑哪些问题。

<!--more-->

易扩展的验证器需要考虑三个最重要的问题

1. 怎样使用最简单的方法增加一种验证逻辑
2. 怎样使现有的验证逻辑能够支持多种数据类型
3. 怎样优雅地支持布尔运算

## 怎样使用最简单的方法增加一种验证逻辑？
假设每个验证器都是一个函数，因为 C++ 语言不支持反射，所以当要判断接下来要运行哪一个验证器时，通常需要使用分支判断，比如 if 和 switch 等，通过一个标志位（字符串，枚举变量）等。这样，每次添加一个验证逻辑（即一个函数），除了函数本身，还需要在分支判断处添加这个验证逻辑的判断逻辑，这个流程不是常数的，每个验证函数都需要经过这一步，才能使这个验证函数被整个验证流程使用。这样做的缺点是最终会使分支判断处的代码变得越来越多。

实际上可以使用 map 这个数据结构，强行模拟一个反射的过程，即所有的验证器都放在一个 map<string, Validator> 中，这样就可以直接通过一个字符串（验证器的名字）直接从 map 中将验证器取出。当然，在新添加验证逻辑时，仍然需要将其添加到这个 map 中，但在使用时会很方便。

## 怎样使现有的验证逻辑能够支持多种数据类型？
这个问题在 C++ 中实现时，很自然地会考虑到使用函数重载或者模板来处理，但用这两中方法来实现最大的问题就是不能很好的解决 “这个字段是一个字符串” 这种校验的问题。可能需要使用模板的特例化来处理，但很容易让代码变得复杂和难以维护。

这里给出的解决方案是，所有用来做验证逻辑的函数都使用 JsonValue 作为参数，好处有以下几点：

1. JsonValue 内部实现是作为一个结构体，保存了各种基本类型用来存储所代表的值，然后记录实际的数据类型。使用这个类型作为函数参数，可以避免使用模板或者参数重载的问题
2. JsonValue 提供了 isString 等函数，用来判断其真实类型
3. JsonValue 本身就重载了各种运算符，可以直接进行比较
4. JsonValue 还实现了 isMember 函数用来判断某个字段是否存在
5. 可以直接使用 json 文件来配置校验所用的参数
6. 可以直接检查到最终用来输出成字符串的 JsonValue 的正确性
7. 可以使用 foo.bar 这种格式获取到 JsonValue 的嵌套成员

## 怎样优雅地支持布尔运算
这里受到了 MongoDB 的启发。

验证器在检查一个 JsonValue 时，最终输出的结果是是否通过验证，这个验证器的作用和过滤器相同，相当于没有通过验证的就是被过滤掉的，通过了验证的就会被留下。

反过来看的话，这个过滤流程实际上和数据库的查询过程是一样的，给定一些列查询条件（过滤器，验证器），满足查询条件的文档会被召回（没有被过滤，通过验证）。所以实现验证器和实现一个简单的数据库查询过程类似。 

下面是一个 MongoDB 查询条件的示例：

``` javascript
{
    $and : [
        { $or : [ { price : 0.99 }, { price : 1.99 } ] },
        { $or : [ { sale : true }, { qty : { $lt : 20 } } ]}
    ]
}
``` 

所以我们把所有具有验证逻辑的校验函数作为一类基本运算符，如果需要支持布尔运算，那还需要一些 $and, $or 等逻辑运算符




